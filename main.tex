%"The PDF file may contain up to 25 pages of reference material, single-sided, letter or A4 size, with text and illustrations readable by a person with correctable eyesight without magnification from a distance of 1/2 meter."
\input{format.tex}
\begin{document}
% Gracias Demetrio
\def\title{Competitive Programming Reference}
.\\[0.2cm]
\centering{\LARGE\textbf{Base Julios GOD}} \\[0.5cm]
% \centering{\includegraphics[width=5.5cm]{img/vasito.jpg}}
\tableofcontents\newpage

\section{Data structures}
\subsection{Segment tree}
    \cppfile{data_structures/segment_tree.cpp}
\subsection{Segment tree - Range update, point query}
    \cppfile{data_structures/segment_tree_range_update_point_query.cpp}
\subsection{Segment tree - Lazy propagation}
    \cppfile{data_structures/segment_tree_lazy.cpp}
\subsection{Segment tree - Persistence}
    \cppfile{data_structures/segment_tree_persistent.cpp}
\subsection{Fenwick tree}
    \cppfile{data_structures/fenwick_tree.cpp}
\subsection{DSU}
    \cppfile{data_structures/dsu.cpp}
\subsection{SQRT decomposition}
    \cppfile{data_structures/sqrt_decomposition.cpp}
\subsection{Trie}
    \cppfile{data_structures/trie.cpp}
\subsection{Trie XOR}
    \cppfile{data_structures/trie_xor.cpp}
\subsection{Map custom hash}
    \cppfile{data_structures/custom_hash.cpp}
\subsection{Ordered set}
    \cppfile{data_structures/ordered_set.cpp}
\subsection{Merge Sort Tree}
    \cppfile{data_structures/merge_sort_tree.cpp}
\subsection{Wavelet Tree}
    \cppfile{data_structures/wavelet_tree.cpp}
\subsection{Monotonic stack}
    \cppfile{data_structures/monotonic_stack.cpp}
\subsection{Matrix operations}
    \cppfile{data_structures/matrix.cpp}
\subsection{Heavy Light Decomposition}
    \cppfile{data_structures/hld.cpp}

\section{Graphs}
\subsection{Euler tour}
    \cppfile{graphs/euler_tour.cpp}
\subsection{Find bridges}
    \cppfile{graphs/find_bridges.cpp}
\subsection{Dijkstra}
    \cppfile{graphs/dijkstra.cpp}
\subsection{Binary Lifting LCA}
    \cppfile{graphs/binary_lifting_lca.cpp}
\subsection{Centroid decomposition}
    \cppfile{graphs/centroid_decomp.cpp}
\subsection{Edmonds karp}
    \cppfile{graphs/edmonds_karp.cpp}
\subsection{Dinics}
    \cppfile{graphs/dinics.cpp}
\subsection{Bipartite check}
    \cppfile{graphs/bipartite_check.cpp}
\subsection{Has cycle?}
    \cppfile{graphs/has_cycle.cpp}
\subsection{Kuhn - matching}
    \cppfile{graphs/kuhn_matching.cpp}
\subsection{Hopcroft Karp - matching}
    \cppfile{graphs/hopcroft_karp_matching.cpp}
\subsection{Min cost - max flow}
    \cppfile{graphs/min_cost_max_flow.cpp}
\subsection{2sat}
    \cppfile{graphs/2sat.cpp}
% \subsection{Segment tree - 2D}
    % \cppfile{data_structures/segment_tree_2d.cpp}

% \subsection{Sparse table (static RMQ)}
%     % \cppfile{data_structures/sparse_table.cpp}
% \subsection{Treap (implicit key)}
%     % \cppfile{data_structures/treap_implicit.cpp}
% \subsection{Treap (with node father)}
%     % \cppfile{data_structures/treap_implicit_father.cpp}


% \section{Graphs}
% \subsection{Topological sort}
%     
% \subsection{Kruskal (+ Union-Find)}
%     % \cppfile{graphs/kruskal.cpp}
% \subsection{Dijkstra}
%     % \cppfile{graphs/dijkstra.cpp}
% \subsection{Bellman-Ford}
%     % \cppfile{graphs/bellman_ford.cpp}
% \subsection{Floyd-Warshall}
%     % \cppfile{graphs/floyd_warshall.cpp}
% \subsection{Strongly connected components (+ 2-SAT)}
%     % \cppfile{graphs/tarjan_2sat.cpp}
% \subsection{Articulation - Bridges - Biconnected}
%     % \cppfile{graphs/articulation_bridges_biconnected.cpp}
% \subsection{Chu-Liu (minimum spanning arborescence)}
%     % \cppfile{graphs/chu_liu.cpp}
% \subsection{LCA - Binary Lifting}
%     % \cppfile{graphs/lca.cpp}
% \subsection{Heavy-Light decomposition}
%     % \cppfile{graphs/hld.cpp}
% \subsection{Centroid decomposition}
%     % \cppfile{graphs/centroid.cpp}
% \subsection{Parallel DFS}
%     % \cppfile{graphs/parallel_dfs.cpp}
% \subsection{Eulerian path}
%     % \cppfile{graphs/eulerian_path.cpp}
% \subsection{Dynamic connectivity}
%     % \cppfile{graphs/dynamic_connectivity.cpp}

\section{Math}
\subsection{Binpow}
    \cppfile{math/binpow.cpp}
\subsection{Modular inverse}
    \cppfile{math/mod_inverse.cpp}
\subsection{Linear Sieve}
    \cppfile{math/linear_sieve.cpp}
\subsection{Factorials}
    \cppfile{math/factorials.cpp}
\subsection{Prime factorization}
    \cppfile{math/prime_factorization.cpp}
\subsection{Divisors}
    \cppfile{math/divisors.cpp}

\subsection{Identities}
{
	$C_n = \frac{2(2n-1)}{n+1} C_{n-1}$

	$C_n = \frac{1}{n+1} \binom{2n}{n}$

	$C_n \sim \frac{4^n}{n^{3/2}\sqrt{\pi}}$

	$\sigma(n) = O(\log(\log(n)))$ (number of divisors of $n$)

	$F_{2n+1} = F_{n}^2 + F_{n+1}^2$

	$F_{2n} = F_{n+1}^2 - F_{n-1}^2$

	$\sum_{i=1}^n F_i = F_{n+2}-1$

	$F_{n+i}F_{n+j} - F_nF_{n+i+j} = (-1)^n F_iF_j$

    (Fermat's little theorem)
    $a^{p}\,mod(p)\,= a\quad$
    $a^{p-1}\,mod(p)\,=1\quad$
    $a^{p-2}\,mod(p)\,=a^{-1}$

	(MÃ¶bius Inv. Formula)
	Let $g(n) = \sum_{d\mid n} f(d)$, then $f(n)=\sum{d\mid n} g(d) \mu\left(\frac{n}{d})\right)$.
}
% \subsection{Theorems}
%     % \cppfile{math/theorems.txt}
% \subsection{Integer floor division}
%     % \cppfile{math/floor_division.cpp}
% %\subsection{Extended Euclid} % allready in diophantine
%     % %\cppfile{math/extended_euclid.cpp}
% \subsection{Sieve of Eratosthenes}
%     % \cppfile{math/sieve.cpp}
% \subsection{Generate divisors}
%     % \cppfile{math/divisors.cpp}
% \subsection{Simpson's rule}
%     % \cppfile{math/simpson.cpp}
% \subsection{Polynomials}
%     % \cppfile{math/polynomial.cpp}
% \subsection{Bairstow}
%     % \cppfile{math/bairstow.cpp}
% \subsection{Fast Fourier Transform}
%     % \cppfile{math/fft.cpp}
% \subsection{Fast Hadamard Transform}
%     % \cppfile{math/fht.cpp}
% \subsection{Karatsuba}
%     % \cppfile{math/karatsuba.cpp}
% \subsection{Diophantine}
%     % \cppfile{math/diophantine.cpp}
% \subsection{Modular inverse}
%     % \cppfile{math/inversemod.cpp}
% \subsection{Chinese remainder theorem}
%     % \cppfile{math/crt.cpp}
% \subsection{Mobius}
%     % \cppfile{math/mobius.cpp}
% \subsection{Matrix exponentiation}
%     % \cppfile{math/matrix_fast_pow.cpp}
% \subsection{Matrix reduce and determinant}
%     % \cppfile{math/matrix_reduce.cpp}
% \subsection{Simplex}
%     % \cppfile{math/simplex.cpp}
% \subsection{Discrete log}
%     % \cppfile{math/discrete_log.cpp}
% \subsection{Berlekamp Massey}
%     % \cppfile{math/berlekamp_massey.cpp}
% \subsection{Linear Rec}
%     % \cppfile{math/linear_rec.cpp}
% \subsection{Tonelli Shanks}
%     % \cppfile{math/tonelli_shanks.cpp}

% \section{Geometry}
% \subsection{Point}
%     % \cppfile{geometry/point.cpp}
% \subsection{Line}
%     % \cppfile{geometry/line.cpp}
% \subsection{Circle}
%     % \cppfile{geometry/circle.cpp}
% \subsection{Polygon}
%     % \cppfile{geometry/polygon.cpp}
% \subsection{Plane}
%     % \cppfile{geometry/plane.cpp}
% \subsection{Radial order of points}
%     % \cppfile{geometry/radial_order.cpp}
% \subsection{Convex hull}
%     % \cppfile{geometry/convex_hull.cpp}
% \subsection{Dual from planar graph}
%     % \cppfile{geometry/planar_graph_dual.cpp}
% \subsection{Halfplane intersection}
%     % \cppfile{geometry/halfplanes.cpp}

% \section{Strings}
% \subsection{KMP}
%     % \cppfile{strings/kmp.cpp}
% \subsection{Z function}
%     % \cppfile{strings/z_function.cpp}
% \subsection{Manacher}
%     % \cppfile{strings/manacher.cpp}
% \subsection{Aho-Corasick}
%     % \cppfile{strings/aho_corasick.cpp}
% \subsection{Suffix automaton}
%     % \cppfile{strings/suffix_automaton.cpp}
% \subsection{Palindromic Tree}
%     % \cppfile{strings/palindromic_tree.cpp}
% \subsection{Suffix array (shorter but slower)}
%     % \cppfile{strings/suffix_array_slow.cpp}
% \subsection{Suffix array}
%     % \cppfile{strings/suffix_array.cpp}
% \subsection{LCP (Longest Common Prefix)}
%     % \cppfile{strings/lcp.cpp}
% \subsection{Suffix Tree (Ukkonen's algorithm)}
%     % \cppfile{strings/suffix_tree.cpp}
% \subsection{Hashing}
%     % \cppfile{strings/hashing.cpp}
% \subsection{Hashing with ll (using \_\_int128)}
%     % \cppfile{strings/hashing_128.cpp}

% \section{Flow}
% \subsection{Matching (slower)}
%     % \cppfile{flow/matching.cpp}
% \subsection{Matching (Hopcroft-Karp)}
%     % \cppfile{flow/hopcroft_karp.cpp}
% \subsection{Hungarian}
%     % \cppfile{flow/hungarian.cpp}
% \subsection{Dinic}
%     % \cppfile{flow/dinic.cpp}
% \subsection{Min cost max flow}
%     % \cppfile{flow/min_cost_max_flow.cpp}

% \section{Other}
% \subsection{Mo's algorithm}
%     % \cppfile{other/mos_algorithm.cpp}
% \subsection{Divide and conquer DP optimization}
%     % \cppfile{other/divide_and_conquer_dp.cpp}
% \subsection{Dates}
%     % \cppfile{other/dates.cpp}
% \subsection{C++ stuff}
%     % \cppfile{other/cpp_stuff.cpp}
% \subsection{Interactive problem tester template}
%     % \cppfile{other/interactive_tester.py}
% \subsection{Max number of divisors up to 10\textsuperscript{n}}
%     % \cppfile{other/hcn.txt}
% \subsection{Template}
%     % \cppfile{other/template.cpp}
\section{Strings}
\subsection{Rolling Hash}
    \cppfile{strings/hashing.cpp}

\section{Geometry}
\subsection{Convex Hull}
    \cppfile{geometry/convex_hull.cpp}

\section{Techniques}
\subsection{MO's algorithm}
    \cppfile{techniques/mos_algorithm.cpp}
\subsection{Parallel binary search}
    \cppfile{techniques/parallel_bs.cpp}
\subsection{Split objects into light and heavy}
    \cppfile{techniques/light_heavy.cpp}
\subsection{Meet in the middle}
    \cppfile{techniques/meet_in_the_middle.cpp}
\subsection{Dijkstra on ST}
    \cppfile{techniques/dijkstra_on_st.cpp}
\subsection{Venice set}
    \cppfile{techniques/venice_set.cpp}

\section{Basic techniques}
\subsection{Difference array}
    \cppfile{basic_techniques/diff_array.cpp}
\subsection{Prefix Sum 2D}
    \cppfile{basic_techniques/prefix_sum_2d.cpp}
\subsection{Random number generator}
    \cppfile{basic_techniques/random.cpp}
\subsection{Coordinate compression}
    \cppfile{basic_techniques/coord_compression.cpp}
\subsection{Digit DP}
    \cppfile{basic_techniques/digit_dp.cpp}
\subsection{Intersection [L1, R1] and [L2, R2]}
    \cppfile{basic_techniques/intersection.cpp}
\end{document}